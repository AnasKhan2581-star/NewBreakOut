<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Breakout Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background-color: #111;
      color: #eee;
      font-family: Arial, sans-serif;
      padding: 10px;
      margin: 0;
    }
    h1, h2 {
      text-align: center;
    }
    h1 {
      color: #00ffae;
      font-size: 6vw;
    }
    h2 {
      color: #ffce00;
      font-size: 5vw;
    }
    .label {
      color: #999;
      display: inline-block;
      min-width: 40%;
    }
    .log-console {
      background: #222;
      color: #0f0;
      font-size: 3vw;
      padding: 10px;
      margin-top: 10px;
      border: 1px solid #444;
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .trade-box {
      background: #1e1e1e;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px;
      margin: 10px 0;
      font-size: 4vw;
    }
    .signals-box {
      margin-top: 10px;
      padding: 8px;
      background: #0a3d0a;
      border-radius: 5px;
      border: 1px solid #00ff00;
    }
    select, button {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      background: #222;
      color: #eee;
      border: 1px solid #333;
      border-radius: 5px;
      font-size: 4vw;
    }
    button:hover {
      background: #333;
      cursor: pointer;
    }
    .info-box {
      background: #1a1a2e;
      border: 1px solid #16213e;
      border-radius: 8px;
      padding: 10px;
      margin: 10px 0;
      font-size: 3.5vw;
      color: #ccc;
    }
    @media (min-width: 768px) {
      h1 { font-size: 2em; }
      h2 { font-size: 1.5em; }
      .trade-box { font-size: 1em; }
      .log-console { font-size: 0.9em; }
      .info-box { font-size: 0.9em; }
      select, button { font-size: 1em; }
    }
  </style>
</head>
<body>
  <h1>üöÄ Enhanced Breakout Scanner (Top 350 Coins by Market Cap)</h1>
  
  <div class="info-box">
    <strong>üìà Advanced Features:</strong><br>
    ‚úÖ Top 350 Coins by Market Cap (CoinGecko)<br>
    ‚úÖ Individual Coin Analysis & Verdict<br>
    ‚úÖ Downtrend Recovery Detection<br>
    ‚úÖ RSI Bullish Divergence<br>
    ‚úÖ Stochastic RSI Bullish Cross<br>
    ‚úÖ Volume Surge Confirmation<br>
    ‚úÖ Recent Resistance Breakout
  </div>

  <label for="timeframe">Select Timeframe:</label>
  <select id="timeframe">
    <option value="1m">1 Minute</option>
    <option value="3m">3 Minutes</option>
    <option value="5m">5 Minutes</option>
    <option value="15m" selected>15 Minutes</option>
    <option value="30m">30 Minutes</option>
    <option value="1h">1 Hour</option>
    <option value="4h">4 Hours</option>
    <option value="1d">1 Day</option>
    <option value="1w">1 Week</option>
  </select>
  <button id="scanButton">üîç Search Enhanced Breakouts</button>
  
  <div style="margin: 20px 0; padding: 15px; background: #1a1a2e; border: 1px solid #16213e; border-radius: 8px;">
    <h3 style="color: #00ffae; margin-top: 0;">üîç Individual Coin Analysis</h3>
    <input type="text" id="coinInput" placeholder="Enter coin symbol (e.g., BTCUSDT)" 
           style="width: 70%; padding: 10px; background: #222; color: #eee; border: 1px solid #333; border-radius: 5px; font-size: 1em; margin-right: 10px;">
    <button id="analyzeCoinButton" style="width: 25%; padding: 10px; margin: 0;">üî¨ Analyze</button>
    <div id="coinAnalysis" style="margin-top: 15px;"></div>
  </div>

  <div id="trades"></div>
  <div class="log-console" id="log-console">Ready to scan for enhanced breakout setups...</div>

  <script>
    const container = document.getElementById("trades");
    const logConsole = document.getElementById("log-console");
    const timeframeSelect = document.getElementById("timeframe");
    const scanButton = document.getElementById("scanButton");
    const analyzeCoinButton = document.getElementById("analyzeCoinButton");
    const coinInput = document.getElementById("coinInput");
    const coinAnalysis = document.getElementById("coinAnalysis");
    const BINANCE_API = 'https://api.binance.com';

    const log = msg => {
      logConsole.innerText += `\n${new Date().toLocaleTimeString()}: ${msg}`;
      logConsole.scrollTop = logConsole.scrollHeight;
    };

    const getCandleCount = tf => {
      const map = { '1m': 200, '3m': 180, '5m': 150, '15m': 120, '30m': 100, '1h': 80, '4h': 60, '1d': 50, '1w': 30 };
      return map[tf] || 100;
    };

    const getProximityPercentage = tf => {
      const map = { '1m': 0.005, '3m': 0.007, '5m': 0.01, '15m': 0.012, '30m': 0.015, '1h': 0.018, '4h': 0.02, '1d': 0.025, '1w': 0.05 };
      return map[tf] || 0.02;
    };

    const fetchTickers = async () => {
      const res = await fetch(`${BINANCE_API}/api/v3/ticker/24hr`);
      const data = await res.json();
      return data.filter(d => d.symbol.endsWith('USDT') && !d.symbol.includes('UP') && !d.symbol.includes('DOWN'))
        .map(d => ({ symbol: d.symbol, volume: parseFloat(d.quoteVolume) }))
        .sort((a, b) => b.volume - a.volume);
    };

    // Fetch top coins by market cap from CoinGecko
    const fetchTopCoinsByRank = async (limit = 350) => {
      try {
        const response = await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${limit}&page=1&sparkline=false`);
        const data = await response.json();
        
        // Convert to Binance USDT pairs
        const coinSymbols = data.map(coin => {
          const symbol = coin.symbol.toUpperCase();
          return `${symbol}USDT`;
        });
        
        // Verify which symbols exist on Binance
        const binanceTickers = await fetchTickers();
        const binanceSymbols = new Set(binanceTickers.map(t => t.symbol));
        
        return coinSymbols.filter(symbol => binanceSymbols.has(symbol))
                         .map(symbol => {
                           const ticker = binanceTickers.find(t => t.symbol === symbol);
                           return { symbol, volume: ticker ? ticker.volume : 0 };
                         });
      } catch (error) {
        console.error('Error fetching CoinGecko data, falling back to Binance volume ranking');
        const tickers = await fetchTickers();
        return tickers.slice(0, limit);
      }
    };

    const fetchCandles = async (symbol, tf, limit) => {
      const res = await fetch(`${BINANCE_API}/api/v3/klines?symbol=${symbol}&interval=${tf}&limit=${limit}`);
      const data = await res.json();
      return data.map(c => ({ time: c[0], open: +c[1], high: +c[2], low: +c[3], close: +c[4], volume: +c[5] }));
    };

    const countTouches = (candles, level, threshold) =>
      candles.filter(c => Math.abs(c.high - level) / level < threshold).length;

    // RSI calculation
    const calculateRSI = (prices, period = 14) => {
      if (prices.length < period + 1) return [];
      const gains = [], losses = [];
      for (let i = 1; i < prices.length; i++) {
        const change = prices[i] - prices[i - 1];
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? Math.abs(change) : 0);
      }
      const rsi = [];
      for (let i = period - 1; i < gains.length; i++) {
        const avgGain = gains.slice(i - period + 1, i + 1).reduce((a, b) => a + b) / period;
        const avgLoss = losses.slice(i - period + 1, i + 1).reduce((a, b) => a + b) / period;
        rsi.push(avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss)));
      }
      return rsi;
    };

    // Stochastic RSI calculation
    const calculateStochRSI = (rsi, period = 14) => {
      if (rsi.length < period) return { k: [], d: [] };
      const stochRSI = [];
      for (let i = period - 1; i < rsi.length; i++) {
        const rsiPeriod = rsi.slice(i - period + 1, i + 1);
        const minRSI = Math.min(...rsiPeriod);
        const maxRSI = Math.max(...rsiPeriod);
        stochRSI.push(maxRSI === minRSI ? 0 : (rsi[i] - minRSI) / (maxRSI - minRSI) * 100);
      }
      // %K line
      const k = [];
      for (let i = 2; i < stochRSI.length; i++) {
        k.push((stochRSI[i] + stochRSI[i-1] + stochRSI[i-2]) / 3);
      }
      // %D line
      const d = [];
      for (let i = 2; i < k.length; i++) {
        d.push((k[i] + k[i-1] + k[i-2]) / 3);
      }
      return { k, d };
    };

    // Check for RSI bullish divergence
    const checkRSIDivergence = (prices, rsi) => {
      if (prices.length < 20 || rsi.length < 20) return false;
      const recentPrices = prices.slice(-20);
      const recentRSI = rsi.slice(-20);
      
      // Find recent low in price
      let priceLowIdx = 0;
      for (let i = 1; i < recentPrices.length - 1; i++) {
        if (recentPrices[i] < recentPrices[priceLowIdx]) priceLowIdx = i;
      }
      
      // Find recent low in RSI
      let rsiLowIdx = 0;
      for (let i = 1; i < recentRSI.length - 1; i++) {
        if (recentRSI[i] < recentRSI[rsiLowIdx]) rsiLowIdx = i;
      }
      
      // Check if price made lower low but RSI made higher low
      if (priceLowIdx < recentPrices.length - 5 && rsiLowIdx < recentRSI.length - 5) {
        const priceRecovery = recentPrices[recentPrices.length - 1] > recentPrices[priceLowIdx];
        const rsiHigherLow = recentRSI[rsiLowIdx] > 30 && recentRSI[recentRSI.length - 1] > recentRSI[rsiLowIdx] + 5;
        return priceRecovery && rsiHigherLow;
      }
      return false;
    };

    // Check for recent downtrend followed by recovery
    const checkDowntrendRecovery = (candles) => {
      if (candles.length < 30) return false;
      const prices = candles.map(c => c.close);
      
      // Check for downtrend in first 60% of period
      const downtrendPeriod = Math.floor(candles.length * 0.6);
      const downtrendCandles = candles.slice(0, downtrendPeriod);
      let downtrendCount = 0;
      for (let i = 5; i < downtrendCandles.length; i++) {
        if (downtrendCandles[i].close < downtrendCandles[i-5].close) downtrendCount++;
      }
      const wasInDowntrend = downtrendCount > downtrendPeriod * 0.4;
      
      // Check for recent recovery with volume
      const recoveryPeriod = candles.slice(downtrendPeriod);
      const avgVolume = candles.slice(0, -5).reduce((a, c) => a + c.volume, 0) / (candles.length - 5);
      let recoveryWithVolume = 0;
      for (let i = 1; i < recoveryPeriod.length; i++) {
        if (recoveryPeriod[i].close > recoveryPeriod[i-1].close && recoveryPeriod[i].volume > avgVolume) {
          recoveryWithVolume++;
        }
      }
      
      return wasInDowntrend && recoveryWithVolume >= 3;
    };

    // Comprehensive coin analysis function
    const analyzeCoin = async (symbol, tf) => {
      const limit = getCandleCount(tf);
      const proximity = getProximityPercentage(tf);
      
      try {
        const candles = await fetchCandles(symbol, tf, limit);
        if (candles.length < 50) {
          return { error: 'Insufficient data for analysis' };
        }

        const recent = candles.slice(-Math.min(40, candles.length));
        const resistance = Math.max(...recent.slice(0, -1).map(c => c.high));
        const touches = countTouches(recent.slice(0, -1), resistance, proximity);
        const last = recent[recent.length - 1];
        const avgVol = recent.slice(0, -1).reduce((a, c) => a + c.volume, 0) / (recent.length - 1);
        
        const atr = recent.slice(-15).reduce((acc, c, i, arr) => {
          if (i === 0) return acc;
          const prev = arr[i - 1].close;
          return acc + Math.max(c.high - c.low, Math.abs(c.high - prev), Math.abs(c.low - prev));
        }, 0) / 14;

        // Technical analysis
        const prices = candles.map(c => c.close);
        const rsi = calculateRSI(prices);
        const stochRSI = calculateStochRSI(rsi);
        
        // Check all criteria
        const hadDowntrendRecovery = checkDowntrendRecovery(candles.slice(-50));
        const hasBullishDivergence = checkRSIDivergence(prices.slice(-30), rsi.slice(-30));
        const hasStochBullishCross = stochRSI.k.length >= 2 && stochRSI.d.length >= 2 &&
          stochRSI.k[stochRSI.k.length - 1] > stochRSI.d[stochRSI.d.length - 1] &&
          stochRSI.k[stochRSI.k.length - 2] <= stochRSI.d[stochRSI.d.length - 2] &&
          stochRSI.k[stochRSI.k.length - 1] < 80;
        
        const volumeSurge = last.volume > avgVol * 1.8;
        
        const recentCandles = candles.slice(-15);
        const recentHighs = recentCandles.map(c => c.high);
        const resistanceLevel = Math.max(...recentHighs.slice(0, -2));
        const resistanceTouches = countTouches(recentCandles.slice(0, -2), resistanceLevel, proximity);
        
        const priceToResistance = (last.close - resistance) / resistance;
        const breakingResistance = last.close > resistanceLevel && last.high > resistanceLevel;
        
        // Final verdict
        const qualifiesForBreakout = touches >= 3 && 
                                   hadDowntrendRecovery && 
                                   hasBullishDivergence && 
                                   hasStochBullishCross && 
                                   volumeSurge && 
                                   breakingResistance &&
                                   resistanceTouches >= 2;

        const entry = last.close;
        const stop = entry - atr * 1.5;
        const targets = findFVGTargets(candles, entry);

        return {
          symbol,
          qualifies: qualifiesForBreakout,
          current_price: last.close.toFixed(6),
          entry: entry.toFixed(6),
          stop_loss: stop.toFixed(6),
          resistance: resistance.toFixed(6),
          recent_resistance: resistanceLevel.toFixed(6),
          fvg_targets: targets.map(x => x.toFixed(6)),
          atr: atr.toFixed(6),
          volume_ratio: (last.volume / avgVol).toFixed(2),
          touches,
          resistance_touches: resistanceTouches,
          rsi_current: rsi.length > 0 ? rsi[rsi.length - 1].toFixed(2) : 'N/A',
          stoch_k: stochRSI.k.length > 0 ? stochRSI.k[stochRSI.k.length - 1].toFixed(2) : 'N/A',
          stoch_d: stochRSI.d.length > 0 ? stochRSI.d[stochRSI.d.length - 1].toFixed(2) : 'N/A',
          criteria: {
            sufficient_touches: touches >= 3,
            downtrend_recovery: hadDowntrendRecovery,
            rsi_divergence: hasBullishDivergence,
            stoch_bullish_cross: hasStochBullishCross,
            volume_surge: volumeSurge,
            breaking_resistance: breakingResistance,
            recent_resistance_formation: resistanceTouches >= 2
          },
          priceToResistance: (priceToResistance * 100).toFixed(2) + '%'
        };

      } catch (error) {
        return { error: error.message };
      }
    };
    const findFVGTargets = (candles, breakoutPrice) => {
      const fvg = [];
      for (let i = 2; i < candles.length - 2; i++) {
        const prevHigh = candles[i - 1].high;
        const nextLow = candles[i + 1].low;
        if (nextLow > prevHigh && nextLow > breakoutPrice && (nextLow - prevHigh) / breakoutPrice > 0.01) {
          fvg.push({ level: nextLow, gap: nextLow - prevHigh });
        }
      }
      return fvg.sort((a, b) => b.gap - a.gap).slice(0, 2).map(f => f.level);
    };

    async function fetchBreakouts(tf) {
      logConsole.innerText = "üîç Starting enhanced breakout scan...";
      container.innerHTML = "";
      
      try {
        log("Fetching top 350 coins by market cap...");
        const topCoins = await fetchTopCoinsByRank(300);
        const candidates = topCoins.slice(30, 150); // Still use ranks 30-150 for scanning
        const setups = [];
        const limit = getCandleCount(tf);
        const proximity = getProximityPercentage(tf);
        let processedCount = 0;

        log(`Analyzing ${candidates.length} coins for advanced patterns...`);

        for (const coin of candidates) {
          try {
            processedCount++;
            log(`[${processedCount}/${candidates.length}] Analyzing ${coin.symbol}`);
            
            const candles = await fetchCandles(coin.symbol, tf, limit);
            if (candles.length < 50) continue;

            const recent = candles.slice(-Math.min(40, candles.length));
            const resistance = Math.max(...recent.slice(0, -1).map(c => c.high));
            const touches = countTouches(recent.slice(0, -1), resistance, proximity);
            const last = recent[recent.length - 1];
            const avgVol = recent.slice(0, -1).reduce((a, c) => a + c.volume, 0) / (recent.length - 1);
            const atr = recent.slice(-15).reduce((acc, c, i, arr) => {
              if (i === 0) return acc;
              const prev = arr[i - 1].close;
              return acc + Math.max(c.high - c.low, Math.abs(c.high - prev), Math.abs(c.low - prev));
            }, 0) / 14;

            // Enhanced analysis with new indicators
            const prices = candles.map(c => c.close);
            const rsi = calculateRSI(prices);
            const stochRSI = calculateStochRSI(rsi);
            
            // Check downtrend recovery pattern
            const hadDowntrendRecovery = checkDowntrendRecovery(candles.slice(-50));
            
            // Check RSI bullish divergence
            const hasBullishDivergence = checkRSIDivergence(prices.slice(-30), rsi.slice(-30));
            
            // Check Stochastic RSI bullish cross
            const hasStochBullishCross = stochRSI.k.length >= 2 && stochRSI.d.length >= 2 &&
              stochRSI.k[stochRSI.k.length - 1] > stochRSI.d[stochRSI.d.length - 1] &&
              stochRSI.k[stochRSI.k.length - 2] <= stochRSI.d[stochRSI.d.length - 2] &&
              stochRSI.k[stochRSI.k.length - 1] < 80; // Not overbought
            
            // Volume surge confirmation
            const volumeSurge = last.volume > avgVol * 1.5;
            
            // Recent resistance formation (looking for consolidation after recovery)
            const recentCandles = candles.slice(-15);
            const recentHighs = recentCandles.map(c => c.high);
            const resistanceLevel = Math.max(...recentHighs.slice(0, -2)); // Exclude last 2 candles
            const resistanceTouches = countTouches(recentCandles.slice(0, -2), resistanceLevel, proximity);
            
            const priceToResistance = (last.close - resistance) / resistance;
            const breakingResistance = last.close > resistanceLevel && last.high > resistanceLevel;
            
            // Enhanced conditions
            const meetsCriteria = touches >= 3 && 
                                 hadDowntrendRecovery && 
                                 hasBullishDivergence && 
                                 hasStochBullishCross && 
                                 volumeSurge && 
                                 breakingResistance &&
                                 resistanceTouches >= 2;

            if (meetsCriteria) {
              const entry = last.close;
              const stop = entry - atr * 1.5;
              const targets = findFVGTargets(candles, entry);
              
              setups.push({
                symbol: coin.symbol,
                entry: entry.toFixed(6),
                stop_loss: stop.toFixed(6),
                resistance: resistance.toFixed(6),
                recent_resistance: resistanceLevel.toFixed(6),
                fvg_targets: targets.map(x => x.toFixed(6)),
                atr: atr.toFixed(6),
                avg_vol: avgVol.toFixed(2),
                vol: last.volume.toFixed(2),
                volume_surge: ((last.volume / avgVol) * 100).toFixed(0) + '%',
                touches,
                resistance_touches: resistanceTouches,
                rsi_current: rsi.length > 0 ? rsi[rsi.length - 1].toFixed(2) : 'N/A',
                stoch_k: stochRSI.k.length > 0 ? stochRSI.k[stochRSI.k.length - 1].toFixed(2) : 'N/A',
                stoch_d: stochRSI.d.length > 0 ? stochRSI.d[stochRSI.d.length - 1].toFixed(2) : 'N/A',
                signals: {
                  downtrend_recovery: hadDowntrendRecovery,
                  rsi_divergence: hasBullishDivergence,
                  stoch_bullish_cross: hasStochBullishCross,
                  volume_surge: volumeSurge,
                  breaking_resistance: breakingResistance
                },
                priceToResistance: (priceToResistance * 100).toFixed(2) + '%'
              });
              
              log(`‚úÖ QUALIFIED: ${coin.symbol} - All criteria met!`);
            }

            // Small delay to prevent rate limiting
            if (processedCount % 10 === 0) {
              await new Promise(resolve => setTimeout(resolve, 100));
            }

          } catch (e) {
            log(`‚ùå Error analyzing ${coin.symbol}: ${e.message}`);
          }
        }

        log(`üéØ Scan complete! Found ${setups.length} qualified setups.`);
        
        setTimeout(() => {
          logConsole.style.display = 'none';
        }, 5000);

        container.innerHTML = setups.length === 0
          ? "<div class='info-box'>‚ùå No qualified breakout setups found. The enhanced scanner looks for coins recovering from downtrends with RSI divergence and Stochastic RSI bullish crosses. Try a different timeframe or check back later.</div>"
          : setups.map(t => `
            <div class="trade-box">
              <h2>üéØ ${t.symbol}</h2>
              <p><span class="label">üí∞ Entry:</span> ${t.entry}</p>
              <p><span class="label">üî¥ Original Resistance:</span> ${t.resistance}</p>
              <p><span class="label">üü° Recent Resistance:</span> ${t.recent_resistance}</p>
              <p><span class="label">üëÜ Resistance Touches:</span> ${t.touches} | Recent: ${t.resistance_touches}</p>
              <p><span class="label">üìä % from Resistance:</span> ${t.priceToResistance}</p>
              <p><span class="label">üõë Stop Loss:</span> ${t.stop_loss}</p>
              <p><span class="label">üéØ FVG Targets:</span> ${t.fvg_targets.length > 0 ? t.fvg_targets.join(' ‚Üí ') : 'No FVG targets'}</p>
              <p><span class="label">üìè ATR:</span> ${t.atr}</p>
              <p><span class="label">üìà Volume Surge:</span> ${t.volume_surge} of avg (${t.avg_vol} ‚Üí ${t.vol})</p>
              <p><span class="label">üìä RSI:</span> ${t.rsi_current} | <span class="label">Stoch K/D:</span> ${t.stoch_k}/${t.stoch_d}</p>
              <div class="signals-box">
                <strong>‚úÖ Confirmed Signals:</strong><br>
                ${Object.entries(t.signals).filter(([k,v]) => v).map(([k,v]) => 
                  'üî• ' + k.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
                ).join('<br>')}
              </div>
            </div>
          `).join('');

      } catch (error) {
        log(`‚ùå Scan failed: ${error.message}`);
        container.innerHTML = `<div class='info-box'>‚ùå Error: ${error.message}. Please check your internet connection and try again.</div>`;
      }
    }

    // Individual coin analysis event handler
    analyzeCoinButton.addEventListener("click", async () => {
      const coinSymbol = coinInput.value.trim().toUpperCase();
      if (!coinSymbol) {
        coinAnalysis.innerHTML = "<div style='color: #ff6b6b;'>‚ùå Please enter a coin symbol</div>";
        return;
      }

      // Ensure symbol ends with USDT
      const symbol = coinSymbol.endsWith('USDT') ? coinSymbol : coinSymbol + 'USDT';
      const tf = timeframeSelect.value;

      coinAnalysis.innerHTML = "<div style='color: #ffd93d;'>üîÑ Analyzing " + symbol + "...</div>";
      analyzeCoinButton.disabled = true;

      try {
        const analysis = await analyzeCoin(symbol, tf);
        
        if (analysis.error) {
          coinAnalysis.innerHTML = `<div style='color: #ff6b6b;'>‚ùå Error: ${analysis.error}</div>`;
          return;
        }

        const verdictColor = analysis.qualifies ? '#00ff88' : '#ff6b6b';
        const verdictText = analysis.qualifies ? '‚úÖ QUALIFIED FOR BREAKOUT' : '‚ùå DOES NOT QUALIFY';
        
        coinAnalysis.innerHTML = `
          <div style="background: #2a2a3e; border: 2px solid ${verdictColor}; border-radius: 10px; padding: 15px; margin-top: 10px;">
            <h3 style="color: ${verdictColor}; margin-top: 0; text-align: center;">
              ${verdictText}
            </h3>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
              <div><strong>üí∞ Current Price:</strong> ${analysis.current_price}</div>
              <div><strong>üéØ Entry:</strong> ${analysis.entry}</div>
              <div><strong>üõë Stop Loss:</strong> ${analysis.stop_loss}</div>
              <div><strong>üìè ATR:</strong> ${analysis.atr}</div>
              <div><strong>üî¥ Resistance:</strong> ${analysis.resistance}</div>
              <div><strong>üü° Recent Resistance:</strong> ${analysis.recent_resistance}</div>
              <div><strong>üëÜ Touches:</strong> ${analysis.touches} | Recent: ${analysis.resistance_touches}</div>
              <div><strong>üìä Volume Ratio:</strong> ${analysis.volume_ratio}x</div>
              <div><strong>üìà RSI:</strong> ${analysis.rsi_current}</div>
              <div><strong>üìä Stoch K/D:</strong> ${analysis.stoch_k}/${analysis.stoch_d}</div>
            </div>
            
            ${analysis.fvg_targets.length > 0 ? 
              `<div><strong>üéØ FVG Targets:</strong> ${analysis.fvg_targets.join(' ‚Üí ')}</div>` : 
              '<div><strong>üéØ FVG Targets:</strong> No targets found</div>'
            }
            
            <div style="margin-top: 15px; padding: 10px; background: #1a1a2e; border-radius: 5px;">
              <strong>üìã Criteria Checklist:</strong><br>
              ${Object.entries(analysis.criteria).map(([key, passed]) => 
                `${passed ? '‚úÖ' : '‚ùå'} ${key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`
              ).join('<br>')}
            </div>
            
            ${analysis.qualifies ? 
              '<div style="margin-top: 10px; padding: 10px; background: #0a3d0a; border-radius: 5px; color: #00ff88;"><strong>üöÄ This coin meets all criteria for a breakout setup!</strong></div>' :
              '<div style="margin-top: 10px; padding: 10px; background: #3d0a0a; border-radius: 5px; color: #ff6b6b;"><strong>‚ö†Ô∏è This coin does not meet the required criteria for our breakout strategy.</strong></div>'
            }
          </div>
        `;

      } catch (error) {
        coinAnalysis.innerHTML = `<div style='color: #ff6b6b;'>‚ùå Error analyzing ${symbol}: ${error.message}</div>`;
      } finally {
        analyzeCoinButton.disabled = false;
      }
    });

    // Allow Enter key to trigger analysis
    coinInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        analyzeCoinButton.click();
      }
    });

    scanButton.addEventListener("click", () => {
      const tf = timeframeSelect.value;
      logConsole.style.display = 'block';
      scanButton.disabled = true;
      scanButton.textContent = 'üîÑ Scanning...';
      
      fetchBreakouts(tf).finally(() => {
        scanButton.disabled = false;
        scanButton.textContent = 'üîç Search Enhanced Breakouts';
      });
    });

    // Initialize
    log("Enhanced Breakout Scanner ready! üöÄ");
  </script>
</body>
</html>
