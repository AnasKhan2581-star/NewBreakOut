<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pro Breakout Setup Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body{background:#111;color:#eee;font-family:Arial,sans-serif;padding:10px;margin:0}
    h1{text-align:center;color:#00ffae;font-size:5vw}
    .info-box{background:#181848;border:1px solid #16213e;border-radius:8px;padding:10px;font-size:1em;margin-bottom:18px}
    .trade-box{background:#1e1e1e;border:2px solid #333;border-radius:12px;padding:13px 14px;margin:11px 0 22px 0;box-shadow:0 2px 8px #0006;}
    .trade-box table{width:96%;background:#181818;margin:7px auto 0;border-radius:8px}
    .trade-box th,.trade-box td{padding:4px 7px}
    .pass{color:#0f0;font-weight:bold;font-size:1.12em}
    .fail{color:#f33;font-weight:bold;font-size:1.12em}
    .log{background:#181818;border-radius:7px;font-size:.99em;color:#a3ffa3;border:1px solid #252;font-family:monospace;padding:8px;min-height:40px;max-height:160px;overflow:auto}
    button, select, input{background:#171831;color:#eee;border:1px solid #31334a;padding:7px 9px;border-radius:6px;font-size:1.11em;margin:7px 0}
    label{font-weight:bold}
    @media (min-width: 620px){.trade-box td,.trade-box th{font-size:1em}}
    @media (max-width: 619px){h1{font-size:8vw}.trade-box, .info-box{font-size:1em}}
  </style>
</head>
<body>
<h1>üöÄ Breakout Trade Setup Scanner</h1>
<div class="info-box">
  <b>Pro breakout setups</b>:<br>
  - Only scans Top 150 Binance USDT coins by volume.<br>
  - Show coins passing at least <b>4/5 high-probability</b> filters:<br>
  <ul>
    <li>Volume surge: &ge; 1.8x recent avg</li>
    <li>Near resistance (&plusmn;1.5%)</li>
    <li>StochRSI bullish cross (not overbought)</li>
    <li>Viable 5.5%+ reward (FVG/next resistance)</li>
    <li>&ge;2:1 risk/reward (ATR stop)</li>
  </ul>
  - Each criterion: <span class="pass">‚úÖ pass</span> / <span class="fail">‚ùå fail</span>
  <br>- Details below each setup.
</div>
<label>Timeframe: 
  <select id="timeframe">
    <option value="1m">1m</option>
    <option value="3m">3m</option>
    <option value="5m">5m</option>
    <option value="15m" selected>15m</option>
    <option value="30m">30m</option>
    <option value="1h">1h</option>
    <option value="4h">4h</option>
    <option value="1d">1d</option>
  </select>
</label>
<button id="scanBtn">üîç Scan Breakouts</button>

<div style="margin:18px 0;padding:10px 20px 17px 20px;background:#171831;border-radius:10px">
  <h3 style="color:#15fa9c;margin:0 0 4px 0;">üî¨ Individual Coin Analysis</h3>
  <input id="coinInput" placeholder="e.g. BTCUSDT" style="width:55%;margin:0 9px 0 0">
  <button id="analyzeBtn">Analyze</button>
  <div id="coinAnalysis" style="margin-top:11px"></div>
</div>
<div class="log" id="log"></div>
<div id="results"></div>
<script>
const API="https://api.binance.com";
const LIMITS = { "1m":220, "3m":180, "5m":150, "15m":120, "30m":100, "1h":80, "4h":60, "1d":50 };
const PROX = 0.015;   // ¬±1.5% for 'near resistance'
const TARGET_MIN_PCT = 5.5; // Minimum 5.5% target
const R_R_MIN = 2.0;  // Minimum risk/reward
const VOL_MULT = 1.8; // Min 1.8x volume
const SLEEP = ms=>new Promise(r=>setTimeout(r,ms));
const log = msg => { let l=document.getElementById("log"); l.textContent+=`\n${msg}`; l.scrollTop=l.scrollHeight; };

// --- Helper TA ---
function avg(arr){ return arr.reduce((s,v)=>s+v,0)/arr.length; }
function RSI(arr,p=14){
  if(arr.length<p+1)return[];
  let g=[],l=[];
  for(let i=1;i<arr.length;i++){
    let d=arr[i]-arr[i-1];
    g.push(d>0?d:0); l.push(d<0?Math.abs(d):0); }
  let res=[];
  for(let i=p-1;i<g.length;i++){
    let avgG=avg(g.slice(i-p+1,i+1)),avgL=avg(l.slice(i-p+1,i+1));
    res.push(avgL===0?100:100-100/(1+avgG/avgL));
  } return res;
}
function StochRSI(rsi,p=14){
  if(rsi.length<p) return {k:[],d:[]};
  let st=[]; for(let i=p-1;i<rsi.length;i++){
    let s=rsi.slice(i-p+1,i+1),mn=Math.min(...s),mx=Math.max(...s);
    st.push(mx===mn?0:(rsi[i]-mn)/(mx-mn)*100);
  }
  let k=[],d=[];
  for(let i=2;i<st.length;i++) k.push((st[i]+st[i-1]+st[i-2])/3);
  for(let i=2;i<k.length;i++) d.push((k[i]+k[i-1]+k[i-2])/3);
  return {k,d};
}
function ATR(candles,p=14){
  let tr=[];
  for(let i=1;i<candles.length;i++){
    let h=candles[i].high,l=candles[i].low,pc=candles[i-1].close;
    tr.push(Math.max(h-l,Math.abs(h-pc),Math.abs(l-pc)));
  }
  if(tr.length<p)return null;
  return avg(tr.slice(-p));
}
// --- Resistance/touches ---
function resistanceLevel(cand,win=40){ return Math.max(...cand.slice(-win-1,-1).map(x=>x.high)); }
function touches(cand,level,prox){ return cand.filter(x=>Math.abs(x.high-level)/level<prox).length; }
// --- FVG/Target Detection ---
function nextFVGTarget(cand,breakout){
  for(let i=cand.length-2;i>10;i--){
    if(
      cand[i+1].low > cand[i-1].high &&
      cand[i+1].low > breakout &&
      (cand[i+1].low - breakout)/breakout > 0.055
    ){
      return {level:cand[i+1].low,pct:((cand[i+1].low-breakout)/breakout)*100,type:"FVG"};
    }
  }
  // fallback: next major high
  let mx=Math.max(...cand.slice(0,-2).map(x=>x.high));
  let pct=(mx-breakout)/breakout*100;
  if(mx>breakout && pct>5.5) return {level:mx,pct,type:"Resist"};
  return null;
}
// -------- Main evaluator: returns detailed breakdown
async function evaluate(symbol,tf){
  const CLIM=LIMITS[tf]||100,prox=PROX;
  let candles=await fetch(`${API}/api/v3/klines?symbol=${symbol}&interval=${tf}&limit=${CLIM}`)
    .then(r=>r.json()).then(r=>r.map(c=>({
      open:+c[1],high:+c[2],low:+c[3],close:+c[4],volume:+c[5],time:c[0]
    })));
  if(candles.length<40)return {error:"Insufficient historical data"};
  let closes=candles.map(c=>c.close),rsi=RSI(closes),{k:K,d:D}=StochRSI(rsi);
  let curr=candles.at(-1),prevs=candles.slice(-21,-1); // last closed candle not counting current
  let resLVL=resistanceLevel(candles);
  let resProxPct=Math.abs(curr.close-resLVL)/resLVL*100, isNearRes=resProxPct<=prox*100;
  let volAvg=avg(prevs.map(x=>x.volume)), volSurge=curr.volume > volAvg*VOL_MULT;
  let stLen=K.length, stochCross = stLen>=2 && K.at(-2)<=D.at(-2) && K.at(-1)>D.at(-1) && K.at(-1)<80;
  let stochVal=`${K.at(-1)?K.at(-1).toFixed(1):'--'}/${D.at(-1)?D.at(-1).toFixed(1):'--'}`;
  let atr=ATR(candles,14) || (resLVL*0.01), stopL=curr.close-atr*2;
  let tgt=nextFVGTarget(candles,curr.close), tgtPct = tgt?tgt.pct:null;
  let rrOK=false, rrv="--", minTgt=false;
  let rr = tgt ? (tgt.level-curr.close)/(curr.close-stopL) : null;
  if(rr!=null){ rrOK=rr>=R_R_MIN; rrv=rr.toFixed(2); }
  minTgt = tgtPct!==null && tgtPct>=TARGET_MIN_PCT;
  let crits = [
    {name:"Volume Surge", val:`${curr.volume.toFixed(0)} / ${volAvg.toFixed(0)}`, pass:volSurge}, 
    {name:"Res. Proximity", val:`${resProxPct.toFixed(2)}%`, pass:isNearRes}, 
    {name:"StochRSI Cross", val:stochVal, pass:stochCross},
    {name:"Target ‚â•5.5%", val:tgtPct!==null?tgtPct.toFixed(2)+"%":"--", pass:minTgt},
    {name:"Risk/Reward ‚â•2", val:rrv, pass:rrOK},
  ];
  let passed=crits.filter(x=>x.pass).length, qualified = passed>=4;
  return {
    symbol, qualified, criteria:crits, price:curr.close, resistance:resLVL, touches:touches(candles.slice(-40),resLVL,prox),
    volume:curr.volume, volAvg, target:tgt?.level||null, targetType:tgt?.type||"--", tgtPct,tgt, stop:stopL,
    rr:rrv, rsiLast:rsi.at(-1)?.toFixed(1)||"--", stochK:K.at(-1)?.toFixed(1)||"--", stochD:D.at(-1)?.toFixed(1)||"--",
    passed
  }
}
// -------- Top150 coins fetcher
async function top150() {
  let data=await fetch(`${API}/api/v3/ticker/24hr`).then(r=>r.json());
  return data.filter(d=>d.symbol.endsWith('USDT')&&!/UP|DOWN/.test(d.symbol))
    .map(d=>({symbol:d.symbol,vol:+d.quoteVolume})).sort((a,b)=>b.vol-a.vol).slice(0,150);
}
// ------- UI rendering ----
function criteriaTable(criteria){
  return `<table style="width:100%;margin-top:7px">`+
    `<tr><th>Criterion</th><th>Status &rarr; Value</th></tr>`+
    criteria.map(c=>
      `<tr><td>${c.name}</td><td class='${c.pass?'pass':'fail'}'>${c.pass?'‚úÖ':'‚ùå'} ${c.val}</td></tr>`
    ).join("")+`</table>`;
}
function tradeBox(r){
  return `<div class='trade-box'>
    <h2>${r.qualified?"‚úÖ":"‚ùå"} <b>${r.symbol}</b> Breakout ${r.qualified?"":"(Not yet)"}</h2>
    <table>
      <tr><td>Current Price</td><td>${r.price.toFixed(6)}</td></tr>
      <tr><td>Resistance</td><td>${r.resistance.toFixed(6)} (${r.touches} touches)</td></tr>
      <tr><td>Volume</td><td>${r.volume.toFixed(0)} (avg: ${r.volAvg.toFixed(0)})</td></tr>
      <tr><td>ATR (14)</td><td>${((r.price-r.stop)/2).toFixed(6)}</td></tr>
      <tr><td>Breakout Target</td><td>${r.target?r.target.toFixed(6):"--"} ${r.tgtPct?`(${r.tgtPct.toFixed(2)}%)`:""}</td></tr>
      <tr><td>Stop Loss</td><td>${r.stop.toFixed(6)}</td></tr>
      <tr><td>Risk/Reward</td><td>${r.rr}</td></tr>
      <tr><td>StochRSI K/D</td><td>${r.stochK}/${r.stochD}</td></tr>
      <tr><td>RSI (14)</td><td>${r.rsiLast}</td></tr>
    </table>
    ${criteriaTable(r.criteria)}
    <div style="margin-top:9px;text-align:center;font-size:1.1em;">
      <b>${r.qualified?`QUALIFIED SETUP (${r.passed}/5)`: `NOT QUALIFIED (${r.passed}/5)`}</b>
    </div>
  </div>`;
}
// ------- Scan Handler --------
async function scanAll(){
  let tf=document.getElementById("timeframe").value;
  let btn=document.getElementById("scanBtn");
  btn.disabled=true; btn.textContent="üîÑ Scanning...";
  log(`\n--- Scanning Top 150 in ${tf}... ---`);
  let coins=await top150();
  let results=[], count=0, found=0;
  for(let c of coins){
    count++;
    try {
      let r=await evaluate(c.symbol,tf);
      if(r && r.passed>=4){ results.push(r); found++; }
      log(`[${count}/150] ${c.symbol} - ${r?`${r.passed}/5`:"fail"}`);
    } catch(e){ log(`Error ${c.symbol}: ${e.message}`);}
    if(count%9==0) await SLEEP(500); // Rate limit
  }
  btn.disabled=false; btn.textContent="üîç Scan Breakouts";
  log(`Done. ${found} coins match ‚â•4/5 criteria.`);
  renderResults(results);
}
function renderResults(arr){
  let box=document.getElementById("results");
  if(!arr.length){ box.innerHTML="<div style='color:#f55;font-size:1.12em;margin:19px 0'>‚ùå No breakouts found this scan.</div>"; return; }
  box.innerHTML=arr.map(tradeBox).join("");
}
// ------- Analyze Handler -------
document.getElementById("analyzeBtn").onclick = async ()=>{
  let ci=document.getElementById("coinInput").value.trim().toUpperCase();
  if(!ci)return;
  if(!ci.endsWith("USDT"))ci+="USDT";
  let tf=document.getElementById("timeframe").value;
  let box=document.getElementById("coinAnalysis");
  box.innerHTML="‚è≥ Analyzing...";
  try {
    let r=await evaluate(ci,tf);
    if(r.error){ box.innerHTML="<span style='color:#f55'>"+r.error+"</span>"; return; }
    box.innerHTML=tradeBox(r);
  } catch(e){ box.innerHTML="<span style='color:#f55'>"+e.message+"</span>"}
};
// ------- Scan Handler --------
document.getElementById("scanBtn").onclick = scanAll;
// Auto clear log on scan
document.getElementById("scanBtn").addEventListener("click",()=>{ document.getElementById("log").textContent=''; });
log("Ready.");
</script>
</body>
</html>
